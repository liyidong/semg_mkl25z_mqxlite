/* ###################################################################
 **     THIS COMPONENT MODULE IS GENERATED BY USER
 **     Filename    : ADC.c
 **     Project     : semg_mkl15z128vlh4
 **     Processor   : MKL15Z128VLH4
 **     Component   : ADS1198
 **     Version     : APRIL 2010-REVISED NOVEMBER 2011
 **     Datasheet   : SBAS471C
 **     Compiler    : GNU C Compiler
 **     Date/Time   : 2013-07-12, 20:06, # CodeGen: 0
 **     Author	    : Dong
 **     Abstract    :
 **			This file contains ADC operation functions.
 **     Settings    :
 **
 **     Contents    :
 **         Init               - void ADCInit(eADCFlag adcFlag);
 **         Configure          - LDD_TError ADCConfigure(eADCFlag adcFlag);
 **         Enable             - LDD_TError ADCEnable(eADCFlag adcFlag);
 **         Disable            - LDD_TError ADCDisable(eADCFlag adcFlag);
 **         StartConvert       - LDD_TError ADCStartConvertByHardware(eADCFlag adcFlag);
 **                            - LDD_TError ADCStartConvertByCommand(eADCFlag adcFlag);
 **         StopConvert        - LDD_TError ADCStopConvertByHardware(eADCFlag adcFlag);
 **                            - LDD_TError ADCStopConvertByCommand(eADCFlag adcFlag);
 **         Reset              - void ADCResetByHardware(eADCFlag adcFlag);
 **                            - LDD_TError ADCResetByCommand(eADCFlag adcFlag);
 **         WakeUp             - LDD_TError ADCWakeUp(eADCFlag adcFlag);
 **         StandBy            - LDD_TError ADCStandBy(eADCFlag adcFlag);
 **         RDATAC             - LDD_TError ADCReadDataContinuous(eADCFlag adcFlag);
 **         SDATAC             - LDD_TError ADCStopReadDataContinuous(eADCFlag adcFlag);
 **         SendCommand        - LDD_TError ADCSendCommand(eADCFlag adcFlag, byte* cmd);
 **         ReadRegister       - LDD_TError ADCReadRegister(eADCFlag adcFlag, byte regAddrbyte* dat, uint8 n);
 **         WriteRegister      - LDD_TError ADCWriteRegister(eADCFlag adcFlag, byte regAddr, byte* dat, uint8 n);
 **         ReadData           - LDD_TError ADCReadContinuousData(eADCFlag adcFlag, byte* dat, uint8 n);
 **                            - LDD_TError ADCReadData(eADCFlag adcFlag, byte* dat, uint8 n);
 **         ADCDataInit        - void ADCDataInit(eADCFlag adcFlag, TADCPtr userDataPtr);
 **         CheckCommand       - LDD_TError CheckCommand(byte cmd);
 **
 **     Mail      	: pzdongdong@163.com
 **
 **     Revision    : No.  Name        Date/Time        Content
 ** ###################################################################*/
/*!
 * @file ADC.c
 * @version 01.00
 * @brief
 * 		This file contains ADC operation functions.
 */
/*!
 *  @addtogroup ADC_module	ADC module documentation
 *      This module contains ADC operation functions.
 *  @{
 */

/* MODULE ADC. */

/* {Default RTOS Adapter} No RTOS includes */
#include "SM_SPI0.h"
#include "BitIO_AD_NOT_RESET0.h"
#include "BitIO_AD_START0.h"
#include "PE_Types.h"
#include "PE_Error.h"
#include "PE_Const.h"
#include "IO_Map.h"
#include "Events.h"
#include "Cpu.h"

#include "limits.h"
#include "string.h"
#include "stdlib.h"

#include "MyHeaders.h"

#define TEST_ADC 0

static LDD_TError CheckCommand(byte cmd);

/*
 * ===================================================================
 * Global Variables
 * ===================================================================
 */

/*
 * ===================================================================
 *     Method      :  ADCInit (Component ADC)
 */
/*!
 *     @brief
 *          Initializes ADC.
 *          The method is called in the PeripheralInit function and will be called
 *          only once.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *          void
 */
/* ===================================================================*/
void ADCInit(EADCFlag adcFlag)
{
    DelaySomeS(1);
    ADCResetByHardware(adcFlag);
    DelaySomeS(1);
    //ADCStopConvertByHardware(adcFlag); /* Clear START, ADC does not convert */
    //DelaySomeMs(1);
    ADCConfigure(adcFlag);             /* Configure the register of ADC. */
    DelaySomeS(1);
}

/*
 * ===================================================================
 *     Method      :  ADCEnable (Component ADC)
 */
/*!
 *     @brief
 *          Signal ~CS is low, enable ADC.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - ERR_OK: Output of this pin is OK.
 *                          - ERR_COMMON: Output of this pin goes wrong.
 */
/* ===================================================================*/
LDD_TError ADCEnable(EADCFlag adcFlag)
{
//    LDD_TError err;

    return ERR_OK;
}

/*
 * ===================================================================
 *     Method      :  ADCDisable (Component ADC)
 */
/*!
 *     @brief
 *          Signal ~CS is High, disable ADC.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - ERR_OK: Output of this pin is OK.
 *                          - ERR_COMMON: Output of this pin goes wrong.
 */
/* ===================================================================*/
LDD_TError ADCDisable(EADCFlag adcFlag)
{
//    LDD_TError err;

    return ERR_OK;
}

/*
 * ===================================================================
 *     Method      : ADCConfigure (Module ADC)
 */
/*!
 *     @brief
 *          Configure the registers of ADC via SPI0.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - See PE_Error.h
 */
/* ===================================================================*/
LDD_TError ADCConfigure(EADCFlag adcFlag)
{
    //LDD_TError err;
    byte cmd;
    byte regVal[28] = {0};  //26 registers and 2 dummy bytes.

    /* Stop Data Continuous mode. */
    cmd = ADC_CMD_SDATAC;
    ADCSendCommand(adcFlag, &cmd);
    while(!tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted || !tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted);
    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;
    tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = FALSE;
    DelaySomeMs(1);

    /* Read ADC ID, should be 0xB6. */
//    cmd = ADC_REG_ID;
//    EnableADCSPI(adcFlag);      /* Select corresponding ADC. */
//    ADCReadRegister(cmd, regVal, 1);
//    while(!tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted || !tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);
//    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;
//    tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = FALSE;
//    DisableADCSPI(adcFlag);         /* De-select ADC. */
//    DelaySomeMs(1);
//#if DEBUG
//    printf("| |  -ID: %#x\n", regVal[2]);
//#endif
//    if(0xB6 != regVal[2])
//    {
//        /* Do something. */
//        for(;;);
//    }

    for(int i = 0; i < 28; i++)
    {
        regVal[i] = 0xFF;
    }

    /* Configure the register in ADC at one time. */
    cmd = ADC_REG_CONFIG1;
#if TEST_ADC == 0
    regVal[0] = (eADC0 == adcFlag) ? 0x23U : 0x03U;  /* CONFIG1, ADC0 output clock for ADC1. */
#elif TEST_ADC == 1
    regVal[0] = (eADC0 == adcFlag) ? 0x26U : 0x06U;    /* Set the frequency to 125. */
#endif
#if TEST_ADC == 0
    regVal[1] = 0x00U;  /* CONFIG2 */
#elif TEST_ADC == 1
    regVal[1] = 0x00U;  /* Test ADC with internal signals. */
#endif
    regVal[2] = 0x80U;  /* CONFIG3 10001100*/
    regVal[3] = 0x00U;  /* LOFF */
#if TEST_ADC == 0
    regVal[4] = 0x40U;  /* CH1SET */
    regVal[5] = 0x40U;  /* CH2SET */
    regVal[6] = 0x40U;  /* CH3SET */
    regVal[7] = 0x40U;  /* CH4SET */
    regVal[8] = 0x40U;  /* CH5SET */
    regVal[9] = 0x40U;  /* CH6SET */
    regVal[10] = 0x40U; /* CH7SET */
    regVal[11] = 0x40U; /* CH8SET */
#elif TEST_ADC == 1
    regVal[4] = 0x01U;  /* CH1SET, short input */
    regVal[5] = 0x01U;  /* CH2SET, short input */
    regVal[6] = 0x01U;  /* CH3SET, short input */
    regVal[7] = 0x01U;  /* CH4SET, short input */
    regVal[8] = 0x01U;  /* CH5SET, short input */
    regVal[9] = 0x01U;  /* CH6SET, short input */
    regVal[10] = 0x01U; /* CH7SET, short input */
    regVal[11] = 0x01U; /* CH8SET, short input */
#endif
    regVal[12] = 0x00U; /* RLD_SENSP */
    regVal[13] = 0x00U; /* RLD_SENSN */
    regVal[14] = 0x00U; /* LOFF_SENSP */
    regVal[15] = 0x00U; /* LOFF_SENSN */
    regVal[16] = 0x00U; /* LOFF_FLIP */
    regVal[17] = 0x00U; /* LOFF_STATP */
    regVal[18] = 0x00U; /* LOFF_STATN */
    regVal[19] = 0x00U; /* GPIO */
    regVal[20] = 0x00U; /* PACE */
    regVal[21] = 0x00U; /* Reserved */
    regVal[22] = 0x00U; /* CONFIG4 */
    regVal[23] = 0x00U; /* WCT1 */
    regVal[24] = 0x00U; /* WCT2 */
    EnableADCSPI(adcFlag);      /* Select corresponding ADC. */
    ADCWriteRegister(cmd, regVal, 25);
    while(!tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted || !tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);
    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;
    tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = FALSE;
    DelaySomeMs(1);
    DisableADCSPI(adcFlag);         /* De-select ADC. */

    for(int i = 0; i < 28; i++)
    {
        regVal[i] = 0xFF;
    }

    EnableADCSPI(adcFlag);
    ADCReadRegister(cmd, regVal, 25);
    while(!tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted || !tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);
    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;
    tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = FALSE;
    DisableADCSPI(adcFlag);

//    for(;;);
//#if DEBUG
//    DelaySomeMs(100);
//    printf("| |  -CONFIG3: %#x\n", regVal[2]);
//    printf("%#x|%#x|%#x|%#x\n%#x|%#x|%#x|%#x|%#x|%#x|%#x|%#x\n", regVal[0], regVal[0], regVal[0], regVal[0],
//                                                                   regVal[0], regVal[0], regVal[0], regVal[0],
//                                                                   regVal[0], regVal[0], regVal[0], regVal[0]);
//#endif
//    for(int i = 0; i < 28; i++)
//    {
//        regVal[i] = 0xFF;
//    }

    /* Read Data Continuous Mode. */
    cmd = ADC_CMD_RDATAC;
    ADCSendCommand(adcFlag, &cmd);
    while(!tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted || !tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted);
    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;
    tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = FALSE;
    DelaySomeMs(1);

    return ERR_OK;
}

/*
 * ===================================================================
 *     Method      :  ADCStartConvertByHardware (Component ADC)
 */
/*!
 *     @brief
 *          Signal START is high, ADC starts to convert.
 *          This function starts ADC to convert via signal START.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - ERR_OK: Output of this pin is OK.
 *                          - ERR_COMMON: Output of this pin goes wrong.
 */
/* ===================================================================*/
LDD_TError ADCStartConvertByHardware(EADCFlag adcFlag)
{
    LDD_TError err;

    if(eADC0 == adcFlag)
    {
        IOADStart0SetVal(); /* Set START, ADC starts to convert */

        if(!IOADStart0GetVal())
        {
            err = ERR_COMMON;
#if DEBUG
            PrintErrorMessage(err);
#endif
        }
        else
        {
            err = ERR_OK;
        }
    }
    else if(eADC1 == adcFlag)
    {
        IOADStart1SetVal(); /* Set START, ADC starts to convert */

        if(!IOADStart1GetVal())
        {
            err = ERR_COMMON;
#if DEBUG
            PrintErrorMessage(err);
#endif
        }
        else
        {
            err = ERR_OK;
        }
    }

    return err;
}

/*
 * ===================================================================
 *     Method      :  ADCStartConvertByCommand (Component ADC)
 */
/*!
 *     @brief
 *          MCU sends START command to ADC, ADC starts to convert.
 *          This function starts ADC to convert via SPI0.
 *          In this method, signal START must be low.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - See PE_Error.h
 */
/* ===================================================================*/
LDD_TError ADCStartConvertByCommand(EADCFlag adcFlag)
{
    LDD_TError err;
    byte cmd = ADC_CMD_START;

    if(eADC0 == adcFlag)
    {
        IOADStart0ClrVal(); /* Clear START, in this method, signal START must be low */
    }
    else if(eADC1 == adcFlag)
    {
        IOADStart1ClrVal(); /* Clear START, in this method, signal START must be low */
    }

    /* Select the corresponding ADC. */
    EnableADCSPI(adcFlag);

    /* Sends START command via SPI0 */
    err = ADCSendCommand(adcFlag, &cmd);
    while(!tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);
    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;

    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);
#endif
    }

    /* De-select ADC. */
    DisableADCSPI(adcFlag);

    return err;
}

/*
 * ===================================================================
 *     Method      :  ADCStopConvertByHardware (Component ADC)
 */
/*!
 *     @brief
 *          Signal START is low, ADC stops converting.
 *          This function starts ADC to convert via signal START.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - ERR_OK: Output of this pin is OK.
 *                          - ERR_COMMON: Output of this pin goes wrong.
 */
/* ===================================================================*/
LDD_TError ADCStopConvertByHardware(EADCFlag adcFlag)
{
    LDD_TError err;

    if(eADC0 == adcFlag)
    {
        IOADStart0ClrVal(); /* Clear START, ADC does not convert */

        if(IOADStart0GetVal())
        {
            err = ERR_COMMON;
#if DEBUG
            PrintErrorMessage(err);
#endif
        }
        else
        {
            err = ERR_OK;
        }
    }
    else if(eADC1 == adcFlag)
    {
        IOADStart1ClrVal(); /* Clear START, ADC does not convert */

        if(IOADStart1GetVal())
        {
            err = ERR_COMMON;
#if DEBUG
            PrintErrorMessage(err);
#endif
        }
        else
        {
            err = ERR_OK;
        }
    }

    return err;
}

/*
 * ===================================================================
 *     Method      :  ADCStartConvertByCommand (Component ADC)
 */
/*!
 *     @brief
 *          MCU sends STOP command to ADC, ADC stops to convert.
 *          This function stops ADC to convert via SPI0.
 *          In this method, signal START must be low.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - See PE_Error.h
 */
/* ===================================================================*/
LDD_TError ADCStopConvertByCommand(EADCFlag adcFlag)
{
    LDD_TError err;
    byte cmd = ADC_CMD_STOP;

    if(eADC0 == adcFlag)
    {
        IOADStart0ClrVal(); /* Clear START, in this method, signal START must be low */
    }
    else if(eADC1 == adcFlag)
    {
        IOADStart1ClrVal(); /* Clear START, in this method, signal START must be low */
    }

    /* Select the correspnoding ADC. */
    EnableADCSPI(adcFlag);

    /* Sends STOP command via SPI0 */
    err = ADCSendCommand(adcFlag, &cmd);
    while(!tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);
    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;
    DelaySomeMs(1);

    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);
#endif
    }

    /* De-select ADC. */
    DisableADCSPI(adcFlag);

    return err;
}

/*
 * ===================================================================
 *     Method      :  ADCResetByHardware (Component ADC)
 */
/*!
 *     @brief
 *          Signal ~RESET varies from high to low to high, ADC resets.
 *          This function resets ADC via signal RESET.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *          void
 */
/* ===================================================================*/
void ADCResetByHardware(EADCFlag adcFlag)
{
    if(eADC0 == adcFlag)
    {
        IOADNotReset0SetVal(); /* Set ~RESET */
        DelaySomeMs(1);
        IOADNotReset0ClrVal(); /* Clear ~RESET, reset ADC */
        DelaySomeMs(1);
        IOADNotReset0SetVal(); /* Set ~RESET */
    }
    else if(eADC1 == adcFlag)
    {
        IOADNotReset1SetVal(); /* Set ~RESET */
        DelaySomeMs(1);
        IOADNotReset1ClrVal(); /* Clear ~RESET, reset ADC */
        DelaySomeMs(1);
        IOADNotReset1SetVal(); /* Set ~RESET */
    }

    return;
}

/*
 * ===================================================================
 *     Method      :  ADCResetByCommand (Component ADC)
 */
/*!
 *     @brief
 *          MCU sends RESET command to ADC, ADC resets.
 *          This function resets ADC via SPI0.
 *          Avoid sending any commands during reset.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - See PE_Error.h
 */
/* ===================================================================*/
LDD_TError ADCResetByCommand(EADCFlag adcFlag)
{
    LDD_TError err;
    byte cmd = ADC_CMD_RESET;

    /* Select the corresponding ADC. */
    EnableADCSPI(adcFlag);

    /* Sends RESET command via SPI0 */
    err = ADCSendCommand(adcFlag, &cmd);
    while(!tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);
    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;
    DelaySomeMs(1);

    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);
#endif
    }

    /* De-select ADC. */
    DisableADCSPI(adcFlag);

    return err;
}

/*
 * ===================================================================
 *     Method      : ADCWakeUp (Component ADC)
 */
/*!
 *     @brief
 *          Send command WAKEUP to ADC via SPI0 to wake up ADC
 *          from low-power standby mode.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - See PE_Error.h
 */
/* ===================================================================*/
LDD_TError ADCWakeUp(EADCFlag adcFlag)
{
    LDD_TError err;
    byte cmd = ADC_CMD_WAKEUP;

    /* Select the corresponding ADC. */
    EnableADCSPI(adcFlag);

    err = ADCSendCommand(adcFlag, &cmd);
    while(!tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);
    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;
    DelaySomeMs(1);

    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);
#endif
    }

    /* De-select ADC. */
    DisableADCSPI(adcFlag);

    return err;
}

/*
 * ===================================================================
 *     Method      : ADCStandBy (Component ADC)
 */
/*!
 *     @brief
 *          Send command STANDBY via SPI0 to make ADC entering
 *          the low-power standby mode.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - See PE_Error.h
 */
/* ===================================================================*/
LDD_TError ADCStandBy(EADCFlag adcFlag)
{
    LDD_TError err;
    byte cmd = ADC_CMD_STANDBY;

    /* Select the corresponding ADC. */
    EnableADCSPI(adcFlag);

    err = ADCSendCommand(adcFlag, &cmd);
    while(!tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);
    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;
    DelaySomeMs(1);

    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);
#endif
    }

    /* De-select ADC. */
    DisableADCSPI(adcFlag);

    return err;
}

/*
 * ===================================================================
 *     Method      : ADCReadDataContinuous (Component ADC)
 */
/*!
 *     @brief
 *          Send command RDATAC via SPI0 to make the conversion data
 *          of ADC can read continuously without command RDATA.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - See PE_Error.h
 */
/* ===================================================================*/
LDD_TError ADCReadDataContinuous(EADCFlag adcFlag)
{
    LDD_TError err;
    byte cmd = ADC_CMD_RDATAC;

    /* Select the corresponding ADC. */
    EnableADCSPI(adcFlag);

    err = ADCSendCommand(adcFlag, &cmd);
    while(!tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);
    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;
    DelaySomeMs(1);

    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);
#endif
    }

    /* De-select ADC. */
    DisableADCSPI(adcFlag);

    return err;
}

/*
 * ===================================================================
 *     Method      : ADCWakeUp (Component ADC)
 */
/*!
 *     @brief
 *          Send command SDATAC to ADC via SPI0 to stop ADC's RDATAC mode.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *                          - See PE_Error.h
 */
/* ===================================================================*/
LDD_TError ADCStopReadDataContinuous(EADCFlag adcFlag)
{
    LDD_TError err;
    byte cmd = ADC_CMD_SDATAC;

    /* Select the corresponding ADC. */
    EnableADCSPI(adcFlag);

    err = ADCSendCommand(adcFlag, &cmd);
    while(!tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);
    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;
    DelaySomeMs(1);

    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);
#endif
    }

    /* De-select ADC. */
    DisableADCSPI(adcFlag);

    return err;
}

/*
 * ===================================================================
 *     Method      : ADCSendCommand (Component ADC)
 */
/*!
 *     @brief
 *          Send command to ADC via SPI0. Please use ADCReadRegister and
 *          ADCWriteRegister, but not this function, to read and write ADC's register!
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @param[in]
 *          cmd             - Pointer to command to be sent.
 *                            See group ADC Commands in Macros.h.
 *     @return
 *                          - Error code of the the transmission status.
 *                          - Possible codes:
 *                              - ERR_OK       - OK.
 *                              - ERR_SPEED    - This device does not work in
 *                                               the active clock configuration.
 *                              - ERR_DISABLED - Component is disabled.
 *                              - ERR_BUSY     - The previous receive request is
 *                                               pending.
 *                              - etc.         - See PE_Error.h.
 */
/* ===================================================================*/
LDD_TError ADCSendCommand(EADCFlag adcFlag, byte* cmd)
{
    LDD_TError err;
    byte dummy = 0;

    /* Check the command. */
    err = CheckCommand(*cmd);
    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);
#endif
        return err;
    }

    /* Select the corresponding ADC. */
    EnableADCSPI(adcFlag);

    /* Try to send the command to ADC. */
    err = SPI0ReceiveSendData(eDMA, (LDD_DMA_TAddress)cmd, (LDD_DMA_TAddress)(&dummy), 1U, 1U);
    //SPI0SendData((LDD_DMA_TAddress)cmd, 1U);
    DelaySomeMs(1);
    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);          /* If error occurred, print the error message */
#endif
    }

    /* De-select ADC. */
    DisableADCSPI(adcFlag);

    return err;
}

/*
 * ===================================================================
 *     Method      : ADCReadRegister (Component ADC)
 */
/*!
 *     @brief
 *          Read data from register of ADC via SPI0.
 *          The data returned in dat[0] and dat[1] are useless. The real data
 *          starts from dat[2]!
 *     @param[in]
 *          regAddr         - The first address of register(s) to be read.
 *     @param[out]
 *          dat             - Pointer to the buffer where received data in.
 *     @param[in]
 *          n               - The number of registers to be read.
 *     @return
 *                          - Error code of the the transmission status.
 *                          - Possible codes:
 *                              - ERR_OK       - OK.
 *                              - ERR_SPEED    - This device does not work in
 *                                               the active clock configuration.
 *                              - ERR_DISABLED - Component is disabled.
 *                              - ERR_BUSY     - The previous receive request is
 *                                               pending.
 *                              - etc.         - See PE_Error.h.
 */
/* ===================================================================*/
LDD_TError ADCReadRegister(byte regAddr, byte* dat, uint8 n)
{
    LDD_TError err;
    byte strCmd[REGISTER_COUNT + 2] = {0};                 /* The read register command is a 2-byte command. */
    uint8 sendByteCount;
    uint8 receiveByteCount;

    /* Check if the register address is valid. */
    if(regAddr < ADC_REG_ID || regAddr > ADC_REG_WCT2)
    {
        err = ERR_PARAM_ADDRESS;
#if DEBUG
        PrintErrorMessage(err);
#endif

        return err;
    }

    /* Check if the reception buffer is valid. */
    if(!dat)
    {
        err = ERR_PARAM_BUFFER_COUNT;
#if DEBUG
        PrintErrorMessage(err);
#endif

        return err;
    }

    /* Check if the number of registers to be read is valid. */
    if(n < MIN_REGISTER_READ_NUMBER || n > MAX_REGISTER_READ_NUMBER)
    {
        err = ERR_RANGE;
#if DEBUG
        PrintErrorMessage(err);
#endif

        return err;
    }

    /* Prepare the command and the register number. */
    strCmd[0] = ADC_CMD_RREG(regAddr);              /* According to user manual, read ADC register command, */
    strCmd[1] = n - 1;                              /* and if the number of registers to be read is n, n - 1 should be sent to ADC. */
    sendByteCount = n + 2;
    receiveByteCount = n + 2;

    /*
     * Try to send and receive the data.
     * Remember that the dat[0] and dat[1] are useless!!!
     * The real data begins at dat[2]!!!
     */
    err = SPI0ReceiveSendData(eDMA, (LDD_DMA_TAddress)strCmd, (LDD_DMA_TAddress)dat,
                              (LDD_DMA_TByteCount)sendByteCount, (LDD_DMA_TByteCount)receiveByteCount);

    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);
#endif
#if DEBUG
        printf("Send command error\n");             /* If error occurred, print message, */
#endif
    }

    return err;
}

/*
 * ===================================================================
 *     Method      : ADCWriteRegister (Component ADC)
 */
/*!
 *     @brief
 *          Write data to register of ADC via SPI0.
 *     @param[in]
 *          regAddr         - The first address of register(s) to be written.
 *     @param[in]
 *          dat             - Pointer to buffer where data to be written in.
 *     @param[in]
 *          n               - The number of registers to be written.
 *     @return
 *                          - Error code of the the transmission status.
 *                          - Possible codes:
 *                              - ERR_OK           - OK.
 *                              - ERR_SPEED        - This device does not work in
 *                                                   the active clock configuration.
 *                              - ERR_DISABLED     - Component is disabled.
 *                              - ERR_BUSY         - The previous receive request is
 *                                                   pending.
 *                              - etc.             - See PE_Error.h.
 */
/* ===================================================================*/
LDD_TError ADCWriteRegister(byte regAddr, byte* dat, uint8 n)
{
    LDD_TError err;
    byte strCmd[REGISTER_COUNT + 2] = {0};                   /* Write register command is a double-byte command. */
    byte dummy[REGISTER_COUNT + 2] = {0};                    /* Receive dummy message. */

    /* Check if the register address is valid. */
    if(regAddr < ADC_REG_ID || regAddr > ADC_REG_WCT2)
    {
        err = ERR_PARAM_ADDRESS;
#if DEBUG
        PrintErrorMessage(err);
#endif

        return err;
    }

    /* Check if the transmission buffer is valid. */
    if(!dat)
    {
        err = ERR_PARAM_BUFFER_COUNT;
#if DEBUG
        PrintErrorMessage(err);
#endif

        return err;
    }

    /* Check if the number of registers to be written is valid. */
    if(n < MIN_REGISTER_READ_NUMBER || n > MAX_REGISTER_READ_NUMBER)
    {
        err = ERR_RANGE;
#if DEBUG
        PrintErrorMessage(err);
#endif

        return err;
    }

    /* Send the write data command to ADC. */
    strCmd[0] = ADC_CMD_WREG(regAddr);              /* According to user manual, write ADC register command, */
    strCmd[1] = n - 1;                              /* and if the number of registers to be written is n, n - 1 should be sent to ADC. */
    for(int i = 0; i < n; i++)
    {
        strCmd[i + 2] = dat[i];
    }

    err = SPI0ReceiveSendData(eDMA, (LDD_DMA_TAddress)strCmd, (LDD_DMA_TAddress)dummy,
                              (LDD_DMA_TByteCount)(n + 2), (LDD_DMA_TByteCount)(n + 2));

    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);
#endif
#if DEBUG
        printf("Send command error\n");             /* If error occurred, print message, */
#endif

    }

    return err;
}

/*
 * ===================================================================
 *     Method      : ADCReadContinuousData (Component ADC)
 */
/*!
 *     @brief
 *          Read conversion data from ADC in RDATAC mode via SPI0.
 *     @param[out]
 *          dat             - Pointer to buffer where received data in.
 *     @param[in]
 *          n               - The length of data bytes to be read.
 *     @return
 *                          - Error code of the the transmission status.
 *                          - Possible codes:
 *                              - ERR_OK       - OK.
 *                              - ERR_SPEED    - This device does not work in
 *                                               the active clock configuration.
 *                              - ERR_DISABLED - Component is disabled.
 *                              - ERR_BUSY     - The previous receive request is
 *                                               pending.
 *                              - etc.         - See PE_Error.h.
 */
/* ===================================================================*/
LDD_TError ADCReadContinuousData(byte* dat, uint8 n)
{
    LDD_TError err;
    byte dummy[RAW_DATA_SIZE] = {0};

    /* Check if the reception buffer is valid. */
    if(!dat)
    {
        err = ERR_PARAM_BUFFER_COUNT;
#if DEBUG
        PrintErrorMessage(err);
#endif

        return err;
    }

    /* Check if the length of data bytes is valid. */
    if(n < 0 || n > RAW_DATA_SIZE)
    {
        err = ERR_PARAM_LENGTH;
#if DEBUG
        PrintErrorMessage(err);
#endif

        return err;
    }

    /* Try to receive data. */
    err = SPI0ReceiveSendData(ePoll, (LDD_DMA_TAddress)dummy, (LDD_DMA_TAddress)dat,
                              (LDD_DMA_TByteCount)n, (LDD_DMA_TByteCount)n);
    if(err != ERR_OK)
    {
#if DEBUG
        PrintErrorMessage(err);
#endif
#if DEBUG
        printf("Send dummy error\n");
#endif
    }

    return err;
}

/*
 * ===================================================================
 *     Method      : ADCReadData (Component ADC)
 */
/*!
 *     @brief
 *          Read conversion data from ADC in RDATA mode via SPI0.
 *          The data returned in dat[0] is useless. The real data
 *          starts from dat[1]!
 *     @param[out]
 *          dat             - Pointer to buffer where received data in.
 *     @param[in]
 *          n               - The length of data bytes to be read.
 *     @return
 *                          - Error code of the the transmission status.
 *                          - Possible codes:
 *                              - ERR_OK       - OK.
 *                              - ERR_SPEED    - This device does not work in
 *                                               the active clock configuration.
 *                              - ERR_DISABLED - Component is disabled.
 *                              - ERR_BUSY     - The previous receive request is
 *                                               pending.
 *                              - etc.         - See PE_Error.h.
 */
/* ===================================================================*/
LDD_TError ADCReadData(byte* dat, uint8 n)
{
    LDD_TError err;
    byte strCmd[RAW_DATA_SIZE + 1] = {0};

    /* Check if the reception buffer is valid. */
    if(!dat)
    {
        err = ERR_PARAM_BUFFER_COUNT;
#if DEBUG
        PrintErrorMessage(err);
#endif

        return err;
    }

    /* Check if the length of data bytes is valid. */
    if(n < 0 || n > RAW_DATA_SIZE)
    {
        err = ERR_PARAM_LENGTH;
#if DEBUG
        PrintErrorMessage(err);
#endif

        return err;
    }

    strCmd[0] = ADC_CMD_RDATA;
    /*
     * Try to send and receive the data.
     * Remember that the dat[0] is useless!!!
     * The real data begins at dat[1]!!!
     */
    err = SPI0ReceiveSendData(eDMA, (LDD_DMA_TAddress)strCmd, (LDD_DMA_TAddress)dat,
                        (LDD_DMA_TByteCount)(n + 1), (LDD_DMA_TByteCount)(n + 1));

    if(err != ERR_OK)
    {
#if DEBUG
        printf("Send command error\n");             /* If error occurred, print message, */
#endif
    }

    return err;
}

/*
 * ===================================================================
 *     Method      : ADCDataInit(Module ADC)
 */
/*!
 *     @brief
 *         	This method initialize the ADC device structure, including
 *         	data, setting and status.
 *     @param[in]
 *         	userDataPtr     - Pointer to specific user data.
 *     @return
 *          void
 */
/* ===================================================================*/
void ADCDataInit(TADCPtr userDataPtr)
{
    extern TADC tADC[USING_ADC_COUNT];
    extern TADCPtr tADCPtr[USING_ADC_COUNT];
    TADC adc;

    memset(&adc, 0xFF, sizeof(TADC));
    adc.adcStatus.adcDataStatus = eIdle;
    adc.adcStatus.transmitionContent = eNothing;

    for(int i = 0; i < CHANNEL_COUNT; i++)
    {
        adc.adcSetting.isChannelEnabled[i] = TRUE;
    }

    adc.adcStatus.isDataReady = FALSE;

    for(int i = 0; i < USING_ADC_COUNT; i++)
    {
        tADC[i] = adc;
        tADCPtr[i] = &tADC[i];
    }

    return;
}

/*
 * ===================================================================
 *     Method      : EnableADCSPI (Module ADC)
 */
/*!
 *     @brief
 *          This method pull the CS signal down to enable corresonding ADC's SPI.
 *          Each time only one ADC's SPI is available.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *          void
 */
/* ===================================================================*/
void EnableADCSPI(EADCFlag adcFlag)
{
    if(eADC0 == adcFlag)
    {
        IOADNotCS1SetVal();
        IOADNotCS0ClrVal();
    }
    else if(eADC1 == adcFlag)
    {
        IOADNotCS0SetVal();
        IOADNotCS1ClrVal();
    }

    return;
}

/*
 * ===================================================================
 *     Method      : DisableADCSPI (Module ADC)
 */
/*!
 *     @brief
 *          This method pull the CS signal up to disable corresonding ADC's SPI.
 *          Each time only one ADC's SPI is disabled.
 *     @param[in]
 *          adcFlag         - Shows which ADC is selected.
 *                            Possible value: eADC0, eADC1.
 *     @return
 *          void
 */
/* ===================================================================*/
void DisableADCSPI(EADCFlag adcFlag)
{
    if(eADC0 == adcFlag)
    {
        IOADNotCS0SetVal();
    }
    else if(eADC1 == adcFlag)
    {
        IOADNotCS1SetVal();
    }

    return;
}

/*
 * ===================================================================
 *     Method      : CheckCommand (Module ADC)
 */
/*!
 *     @brief
 *         	This method checks if the command is valid.
 *     @param[in]
 *         	cmd             - Command to be checked.
 *     @return
 *         	                - ERR_OK: Command is valid and the length is legal.
 *         	                - ERR_PARAM_COMMAND: Command is invalid.
 *         	                - ERR_PARAM_LENGTH: Length is illegal.
 */
/* ===================================================================*/
static LDD_TError CheckCommand(byte cmd)
{
    if(cmd != ADC_CMD_WAKEUP  &&
       cmd != ADC_CMD_STANDBY &&
       cmd != ADC_CMD_RESET   &&
       cmd != ADC_CMD_START   &&
       cmd != ADC_CMD_STOP    &&
       cmd != ADC_CMD_RDATAC  &&
       cmd != ADC_CMD_SDATAC  &&
       cmd != ADC_CMD_RDATA   &&
       (cmd < ADC_CMD_RREG(ADC_REG_ID) || cmd > ADC_CMD_RREG(ADC_REG_WCT2)) &&
       (cmd < ADC_CMD_WREG(ADC_REG_ID) || cmd > ADC_CMD_WREG(ADC_REG_WCT2))
      )
    {
        return ERR_PARAM_COMMAND;
    }

    return ERR_OK;
}

/* END ADC. */

/*!
 * @}
 */
/*
 ** ###################################################################
 **
 **     This file was created by Dong
 **     for the Freescale Kinetis series of microcontrollers.
 **
 ** ###################################################################
 */
