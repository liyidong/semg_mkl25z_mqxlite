/* ###################################################################
 **     THIS COMPONENT MODULE IS GENERATED BY USER.
 **     Filename    : Macros.c
 **     Project     : semg_mkl15z128vlh4
 **     Processor   : MKL15Z128VLH4
 **     Component   :
 **     Version     :
 **     Compiler    : GNU C Compiler
 **     Date/Time   : 2013-07-12, 12:30, # CodeGen: 0
 **     Author      : Dong
 **     Abstract    :
 **          This file contains user macros used in this project.
 **
 **
 **     Mail        : pzdongdong@163.com
 **
 **     Revision    : No.  Name        Date/Time        Content
 ** ###################################################################*/
/*!
 * @file Macros.c
 * @version 01.00
 * @brief
 *      This file contains user macros used in this project.
 *
 */
/*!
 *  @addtogroup UserMacros User Macros
 *      This module contains user macros used in this project.
 *  @{
 */
/* MODULE USER MACROS */

#include "Macros.h"

/*
 * ===================================================================
 * User Macros Definition
 * ===================================================================
 */

    /*
     * ===================================================================
     * System Constants
     * ===================================================================
     */
    /*!
     * @addtogroup SysConst System Constants
     * @{
     */
#if USING_MKL15Z128VLH4
const uint32 MIN_SYSTICK_VALUE = 0x01;                                     /*!< Minimum value of the SysTick value register. */
const uint32 MAX_SYSTICK_VALUE = 0xFFFFFF;                                 /*!< Maximum value of the SysTick value register. */
const uint32 TICK_TO_US_PROCESSOR_CLOCK = 48;                              /*!< 48 ticks equals to 1us, when using processor clock(48MHz). */
const uint32 TICK_TO_US_EXTERNAL_CLOCK = 3;                                /*!< 3 ticks equals to 1us, when using external clock(3MHz). */
const uint32 TICK_TO_MS_PROCESSOR_CLOCK = 48000;                           /*!< 4800 ticks equals to 1ms, when using processor clock(48MHz). */
const uint32 TICK_TO_MS_EXTERNAL_CLOCK = 3000;                             /*!< 3000 ticks equals to 1ms, when using external clock(3MHz). */
const uint32 MIN_DELAY_US = 5;                                             /*!< Minimum microseconds to delay when using SysTick. */
const uint32 MIN_DELAY_TIME = 1;                                           /*!< Minimum delay time is 1us/ms/s. */
    #if PROCESSOR_CLOCK_48MHZ
const uint32 PROCESSOR_CLOCK = 48;                                         /*!< Processor clock frequency is 48MHz. */
const uint32 MAX_DELAY_US_PROCESSOR_CLOCK = 349525;                        /*!< Maximum delay microseconds of a 48MHz is 349525us. */
const uint32 MAX_DELAY_MS_PROCESSOR_CLOCK = 349;                           /*!< Maximum delay milliseconds of a 48MHz is 349ms. */
const uint32 MAX_DELAY_MS_EXTERNAL_CLOCK = 5592;                           /*!< Maximum delay milliseconds of a 3MHz is 5592ms. */
    #endif  /* #if PROCESSOR_CLOCK_48MHZ */
const uint32 SYSTICK_USE_PROCESSOR_CLOCK = 0x01U;                          /*!< SysTick uses processor clock, equlas to SysTick_PDD_CORE_CLOCK. */
const uint32 SYSTICK_USE_EXTERNAL_CLOCK = 0x0U;                            /*!< SysTick uses external clock. equals to SysTick_PDD_CORE_CLOCK_DIV16.*/
const uint8 MCU_NUMBER = 0x00U;                                             /*!< The number of MCU. */
#endif  /* #if USING_MKL15Z128VLH4 */
    /*!
     * @}
     */
    /*!
     * @addtogroup ADCConst ADC Constants
     * @{
     */
#if USING_ADS1198
const uint8 MIN_CHANNEL_NUMBER = 0x00;                                     /*!< Minimum number of ADC channels. */
const uint8 MAX_CHANNEL_NUMBER = 0x08;                                     /*!< Maximum number of ADC channels. */
const uint8 MIN_REGISTER_READ_NUMBER = 0x01;                               /*!< Minimum number of registers to be read. */
const uint8 MAX_REGISTER_READ_NUMBER = 0x20;                               /*!< Maximum number of registers to be read. */
const byte RAW_DATA_HEAD = 0x0C;                                           /*!< The first 4 bits of right ADC value must be 0b1100. */
const uint8 RAW_DATA_HEAD_MASK = 0x0F;                                     /*!< The mask of first 4 bits. The right value is always 0b1100. */
const uint8 RAW_DATA_GPIO_MASK = 0x0F;                                     /*!< The mask of GPIO data of ADC value. */
const uint8 BYTE_COUNT_PER_CHANNEL = 0x02;                                 /*!< The count of bytes per channel's data. */
#endif  /* #if USING_ADS1198 */
    /*!
     * @}
     */
    /*!
     * @addtogroup DMAConst DMA constants
     * @{
     */
#if USING_DMA
const uint8 SPI0_TX_DMA_CHANNEL = 0x00;
const uint8 SPI0_RX_DMA_CHANNEL = 0x01;
const uint8 SPI1_TX_DMA_CHANNEL = 0x02;
const uint8 SPI1_RX_DMA_CHANNEL = 0x03;
#endif /* #if USING_DMA */
    /*!
     * @}
     */
    /*!
     * @addtogroup ARMConst ARM constants
     * @{
     */
/*!
 * The length of channel package.
 *
   @verbatim
   ----------------------------------------------------------------------------------------
   |0x11|channel_num|channel_state|(channel_data_high+channel_data_low)*CHANNEL_DATA_COUNT|
   ----------------------------------------------------------------------------------------
   @endverbatim
 */
const byte CHANNEL_PACKAGE_HEAD_BIT = 0x11;                                /*!< The head bit of channel data package. */

/*!
 * The length of data frame.
 *
   @verbatim
   ---------------------------------------------------------------------------------------------------------------------------------
   |0xb7|branch_num|channel_package_length_high|channel_package_length_low|channel_package*USING_CHANNEL_COUNT*USING_ADC_COUNT|0xed|
   ---------------------------------------------------------------------------------------------------------------------------------
   @endverbatim
 */
const uint8 DATA_FRAME_HEAD_SIZE = 8U;                                     /*!< The size of the head of data frame. */
const uint8 DATA_FRAME_TAIL_SIZE = 1U;                                     /*!< The size of the tail of data frame. */
const byte DATA_FRAME_HEAD_BIT = 0xB7;                                     /*!< The head bit of data frame. */
const byte DATA_FRAME_TAIL_BIT = 0xED;                                     /*!< The tail bit of data frame. */
    /*!
     * @}
     */

    /*
     * ===================================================================
     * ADC Commands and Registers Map
     * ===================================================================
     */
    /*!
     * @addtogroup ADCCmdReg ADC Commands and Registers Map
     * @{
     */
        /*!
         * @addtogroup ADCCmd ADC Commands
         * @{
         */
#if USING_ADS1198

const byte ADC_CMD_WAKEUP = 0x02;
const byte ADC_CMD_STANDBY = 0x04;
const byte ADC_CMD_RESET = 0x06;
const byte ADC_CMD_START = 0x08;
const byte ADC_CMD_STOP = 0x0a;
const byte ADC_CMD_RDATAC = 0x10;                                          /*!< ADC runs in Read Data Continuous mode. */
const byte ADC_CMD_SDATAC = 0x11;                                          /*!< Cancel RDATAC mode. */
const byte ADC_CMD_RDATA = 0x12;                                           /*!< If in SDATAC mode, read data from ADC when ~DRDY goes low. */
        /*!
         * @}
         */
        /*!
         * @addtogroup ADCReg ADC Registers
         * @{
         */
            /*!
             * @addtogroup DevSet Device Settings
             * @{
             */
const byte ADC_REG_ID = 0X00;                                              /*!< Read-only register. */
            /*!
             * @}
             */
            /*!
             * @addtogroup GblSet Global Settings Across Channels
             * @{
             */
const byte ADC_REG_CONFIG1 = 0x01;
const byte ADC_REG_CONFIG2 = 0x02;
const byte ADC_REG_CONFIG3 = 0x03;
const byte ADC_REG_LOFF = 0x04;
            /*!
             * @}
             */
            /*!
             * @addtogroup  ChnSet Channel-Specific Settings
             * @{
             */
const byte ADC_REG_CH1SET = 0x05;
const byte ADC_REG_CH2SET = 0x06;
const byte ADC_REG_CH3SET = 0x07;
const byte ADC_REG_CH4SET = 0x08;
const byte ADC_REG_CH5SET = 0x09;                                          /*!< Not available for the ADS1194. */
const byte ADC_REG_CH6SET = 0x0A;                                          /*!< Not available for the ADS1194. */
const byte ADC_REG_CH7SET = 0x0B;                                          /*!< Not available for the ADS1194 and ADS1196. */
const byte ADC_REG_CH8SET = 0x0C;                                          /*!< Not available for the ADS1194 and ADS1196. */
const byte ADC_REG_RLD_SENSP = 0x0D;                                       /*!< Bits[7:4] are not available for the ADS1194. Bits[7:6] are not available for the ADS1196. */
const byte ADC_REG_RLD_SENSN = 0x0E;                                       /*!< Bits[7:4] are not available for the ADS1194. Bits[7:6] are not available for the ADS1196. */
const byte ADC_REG_LOFF_SENSP = 0x0F;                                      /*!< Bits[7:4] are not available for the ADS1194. Bits[7:6] are not available for the ADS1196. */
const byte ADC_REG_LOFF_SENSN = 0x10;                                      /*!< Bits[7:4] are not available for the ADS1194. Bits[7:6] are not available for the ADS1196. */
const byte ADC_REG_LOFF_FLIP = 0x11;
            /*!
             * @}
             */
            /*!
             * @addtogroup  LOFFStatReg Lead-Off Status Registers
             * @{
             */
const byte ADC_REG_LOFF_STATP = 0x12;                                      /*!< Read-only register. */
const byte ADC_REG_LOFF_STATN = 0x13;                                      /*!< Read-only register. */
            /*!
             * @}
             */
            /*!
             * @addtogroup  GPIO_Oth GPIO and OTHER Registers
             *      Address 16h is reserved.
             * @{
             */
const byte ADC_REG_GPIO = 0x14;
const byte ADC_REG_PACE = 0x15;
/* const byte ADC_REG_RESERVED = 0x16; */                                  /* Reserved. */
const byte ADC_REG_CONFIG4 = 0x17;
const byte ADC_REG_WCT1 = 0x18;
const byte ADC_REG_WCT2 = 0x19;

#endif /* #if USING_ADS1198 */
            /*!
             * @}
             */
        /*!
         * @}
         */
    /*!
     * @}
     */
/*
 * ===================================================================
 * Error Message
 * ===================================================================
 */

    /*!
     * @addtogroup ErrMsg Error Message
     * @{
     */
#if DEBUG
const char* const ERR_MSG_OK                  = "OK.\n";
const char* const ERR_MSG_SPEED               = "This device does not work in the active speed mode.\n";
const char* const ERR_MSG_RANGE               = "Parameter out of range.\n";
const char* const ERR_MSG_VALUE               = "Parameter of incorrect value.\n";
const char* const ERR_MSG_OVERFLOW            = "Timer overflow.\n";
const char* const ERR_MSG_MATH                = "Overflow during evaluation.\n";
const char* const ERR_MSG_ENABLED             = "Device is enabled.\n";
const char* const ERR_MSG_DISABLED            = "Device is disabled.\n";
const char* const ERR_MSG_BUSY                = "Device is busy.\n";
const char* const ERR_MSG_NOTAVAIL            = "Requested value or method not available.\n";
const char* const ERR_MSG_RXEMPTY             = "No data in receiver.\n";
const char* const ERR_MSG_TXFULL              = "Transmitter is full.\n";
const char* const ERR_MSG_BUSOFF              = "Bus not available.\n";
const char* const ERR_MSG_OVERRUN             = "Overrun error is detected.\n";
const char* const ERR_MSG_FRAMING             = "Framing error is detected.\n";
const char* const ERR_MSG_PARITY              = "Parity error is detected.\n";
const char* const ERR_MSG_NOISE               = "Noise error is detected.\n";
const char* const ERR_MSG_IDLE                = "Idle error is detected.\n";
const char* const ERR_MSG_FAULT               = "Fault error is detected.\n";
const char* const ERR_MSG_BREAK               = "Break char is received during communication.\n";
const char* const ERR_MSG_CRC                 = "CRC error is detected.\n";
const char* const ERR_MSG_ARBITR              = "A node losts arbitration. This error occurs if two nodes start transmission at the same time.\n";
const char* const ERR_MSG_PROTECT             = "Protection error is detected.\n";
const char* const ERR_MSG_UNDERFLOW           = "Underflow error is detected.\n";
const char* const ERR_MSG_UNDERRUN            = "Underrun error is detected.\n";
const char* const ERR_MSG_COMMON              = "Common error of a device.\n";
const char* const ERR_MSG_LINSYNC             = "LIN synchronization error is detected.\n";
const char* const ERR_MSG_FAILED              = "Requested functionality or process failed.\n";
const char* const ERR_MSG_QFULL               = "Queue is full.\n";
const char* const ERR_MSG_WRITE_FAILED        = "Fail to write data.\n";
const char* const ERR_MSG_PARAM_MASK          = "Invalid mask.\n";
const char* const ERR_MSG_PARAM_MODE          = "Invalid mode.\n";
const char* const ERR_MSG_PARAM_INDEX         = "Invalid index.\n";
const char* const ERR_MSG_PARAM_DATA          = "Invalid data.\n";
const char* const ERR_MSG_PARAM_SIZE          = "Invalid size.\n";
const char* const ERR_MSG_PARAM_VALUE         = "Invalid value.\n";
const char* const ERR_MSG_PARAM_RANGE         = "Invalid parameter's range or parameters' combination.\n";
const char* const ERR_MSG_PARAM_LOW_VALUE     = "Invalid value (LOW part).\n";
const char* const ERR_MSG_PARAM_HIGH_VALUE    = "Invalid value (HIGH part).\n";
const char* const ERR_MSG_PARAM_ADDRESS       = "Invalid address.\n";
const char* const ERR_MSG_PARAM_PARITY        = "Invalid parity.\n";
const char* const ERR_MSG_PARAM_WIDTH         = "Invalid width.\n";
const char* const ERR_MSG_PARAM_LENGTH        = "Invalid length.\n";
const char* const ERR_MSG_PARAM_ADDRESS_TYPE  = "Invalid address type.\n";
const char* const ERR_MSG_PARAM_COMMAND_TYPE  = "Invalid command type.\n";
const char* const ERR_MSG_PARAM_COMMAND       = "Invalid command.\n";
const char* const ERR_MSG_PARAM_RECIPIENT     = "Invalid recipient.\n";
const char* const ERR_MSG_PARAM_BUFFER_COUNT  = "Invalid buffer count.\n";
const char* const ERR_MSG_PARAM_ID            = "Invalid ID.\n";
const char* const ERR_MSG_PARAM_GROUP         = "Invalid group.\n";
const char* const ERR_MSG_PARAM_CHIP_SELECT   = "Invalid chip select.\n";
const char* const ERR_MSG_PARAM_ATTRIBUTE_SET = "Invalid set of attributes.\n";
const char* const ERR_MSG_PARAM_SAMPLE_COUNT  = "Invalid sample count.\n";
const char* const ERR_MSG_PARAM_CONDITION     = "Invalid condition.\n";
const char* const ERR_MSG_PARAM_TICKS         = "Invalid ticks parameter.\n";
const char* const ERR_MSG_UNKNOWN             = "Unknown error.\n";
#endif  /* #if DEBUG */
    /*!
     * @}
     */

    /* END Macros. */
/*!
 * @}
 */
/*
 ** ###################################################################
 **
 **     This file was created by Dong
 **     for the Freescale Kinetis series of microcontrollers.
 **
 ** ###################################################################
 */
